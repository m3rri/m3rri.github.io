{"pageProps":{"post":{"id":"20230526","content":"\n## MapStruct로 dto 매핑 지옥 탈출\n\n### 적용 배경\n\n-   프로젝트 개발 중 변수가 40개 이상이되는 테이블을 조회해서 DTO로 변환 후 리턴해줘야하는 API를 만났다\n-   getter setter 좍좍 타이핑할 생각에 정신이 아득해져서 구글링으로 Entity to Dto 를 검색했다\n-   ModelMapper 라이브러리를 발견 후 적용해보려는데 나랑 너무 안맞아서 다른 라이브러리를 찾아보았고 그것이 MapStruct이다\n\n### MapStruct 시작하기\n\n1. 의존성 추가하기 `build.gradle`\n\n    lombok 사용하는 경우 작성 순서가 매우 중요하다 👉 lombok 이후에 정의\n\n    ```gradle\n    dependencies {\n        ...\n        implementation 'org.projectlombok:lombok'\n        annotationProcessor 'org.projectlombok:lombok'\n        implementation 'org.mapstruct:mapstruct:1.5.3.Final'\n        annotationProcessor 'org.mapstruct:mapstruct-processor:1.5.3.Final'\n        ...\n    }\n    ```\n\n2. Mapper interface 작성\n\n    ```java\n    import org.mapstruct.Mapper;\n    import org.mapstruct.Mapping;\n    import org.mapstruct.factory.Mappers;\n\n    @Mapper //어노테이션 적용\n    public interface ConditionsMapper {\n        ConditionsMapper INSTANCE = Mappers.getMapper(ConditionsMapper.class);\n        // Mappers.getMapper()로 싱글톤 생성하여 INSTANCE를 호출해서 사용\n\n        /* abstract method 정의\n         * @Mapping : 해당 어노테이션을 통해 변수 이름만으로 생성된 getter, setter만으로 매핑이 불가능한 경우를 정의\n         *  * source : method의 파라미터중에서 어떤 파라미터를 사용하여 매핑할 것인지 명시하면 됨\n              예시 코드에서는 method 파라미터가 1개이지만, 2개 이상의 객체를 받아서 하나의 target 객체로 매핑하는 경우도 정의할 수 있다.\n              단, 하나의 @Mapping source 속성에서 하나의 파라미터 객체만 다룰 수 있음 -> @Mapping 여러개를 사용할 수 있음\n         *  * target : method의 리턴 타입\n         */\n        @Mapping(source = \"condition.equipmentType\", target = \"equipmentType\", qualifiedByName = \"equipmentTypeToString\")\n        /* ☝ source쪽 객체에서 equipmentType이라는 변수의 타입이 EquipmentType이라는 Enum객체인데,\n           target쪽 객체에서는 String type으로 정의되어있는 경우 -> 별도 설정 없으면 Enum name이 그대로 target으로 매핑됨\n           이 경우 Enum에서 별도로 사용하고 싶은 fullName을 지정했다고 가정하고 그것을 매핑하는 방법을 예로 들었음 */\n        @Mapping(source = \"condition\", target = \"product\", qualifiedByName = \"productToBaseProduct\")\n        /* ☝ source 객체 자체를 target 변수에 매핑하는데 사용할 수 있음\n           이 경우 equipmentType별로 매핑해야하는 Product 클래스가 다른 경우를 가정하고 예를 들었음 */\n        @Mapping(source = \"condition.param\", target = \"params\")\n        /* ☝ 단순히 변수의 이름만 다른 경우 위와 같이 간단하게 정의할 수 있음\n           이 경우 source의 param은 List<Param>이고 target에 List<ParamDto> params로 정의되어 있는 경우를 가정하였고\n           MapStruct에서 알아서 객체, 콜렉션 매핑에 필요한 메소드를 2개 생성함 */\n        ConditionDto toConditionDto(Condition condition);\n\n        //변수명, 타입 등에서 특이사항이 없는 경우 아래와 같이 추상메소드 정의만 해두면 매핑 코드가 생성된다.\n        ProductChild1 toChild1(Product product);\n        ProductChild2 toChild2(Product product);\n\n        /* static method 구현\n         * toConditionDto 메소드의 첫번째 @Mapping 설정 중 qualifiedByName 속성에서 호출하게 될 메소드를 구현한 영역이다.\n         * MapStruct가 매핑 클래스를 구현해줄 때 @Named 어노테이션에 작성한 이름으로 코드를 작성하기 때문에 qualifiedByName이랑 맞춰줘야함\n         */\n        @Named(\"equipmentTypeToString\")\n        static String equipmentTypeToString(EquipmentType equipmentType){\n            return equipmentType.getFullName();\n        }\n\n        @Named(\"productToBaseProduct\")\n        static BaseProduct productToBaseProduct(Condition condition){\n            BaseProduct returnProduct = null;\n            Product product = condition.getProduct();\n\n            switch (condition.getEquipmentType()){\n            case EQUIP1:\n                returnProduct = INSTANCE.toChild1(product);\n                break;\n            case EQUIP2:\n                returnProduct = INSTANCE.toChild2(product);\n                break;\n            }\n\n            return returnProduct;\n        }\n    }\n    ```\n\n3. 컴파일 후 자동 생성된 클래스 구경\n\n    너무 길어서..👉 [gist link](https://gist.github.com/m3rri/1c689ede6e8fdd112db1269966c96d87)\n\n4. 2에서 생성한 INSTANCE를 통해 메소드 호출\n\n    ```java\n    public ConditionDto getCondition(Long id){\n        ...\n        Condition condition = conditionRepository.findById(id);\n\n        return ConditionMapper.INSTANCE.toConditionDto(condition);\n    }\n    ```\n\n### MapStruct와 ModelMapper의 차이점 (=MapStruct가 더 좋은 이유)\n\n-   ModelMapper\n    -   Collection, Enum 타입의 변수를 변환할 때 작성하는 코드가 너무 장황함\n    -   런타임에서 예외를 반환함\n    -   문제가 있을 때 디버깅이 불가능함\n-   MapStruct\n    -   Collection, Enum 타입 변환 코드가 간단함\n    -   컴파일할 때 예외를 반환함\n    -   디버깅이 쉬움 : _인터페이스로 매핑할 내용을 정의하면 컴파일 시 getter, setter를 사용한 클래스를 자동생성해주기 때문에_\n-   Collection type 변환 코드 비교\n    -   조회 결과가 findAll인 경우\n        ```java\n        // ModelMapper\n        List<User> users = userRepository.getUsers();\n        List<UserDto> userList = users.stream()\n                .map(user -> modelMapper.map(user, UserDto.class))\n                .collect(Collectors.toList());\n        ```\n        ```java\n        // MapStruct\n        UserDto toUserDto(User user);\n        List<UserDto> toUserDtoList(List<User> users);\n        ```\n    -   조회 결과가 findOne인 경우\n        ```java\n        // ModelMapper\n        User user = orderRepository.getOrdersGroupByUser();\n        List<OrderDto> orders = user.getOrders()\n                .map(order -> modelMapper.map(order, OrderDto.class))\n                .collect(Collectors.toList());\n        UserDto userDto = modelMapper.map(user, UserDto.class);\n        userDto.setOrders(orders);\n        ```\n        ```java\n        // MapStruct : findAll에서 작성한 toUserDto로 처리 가능\n        ```\n-   Enum type 변환 코드 비교\n\n    -   Enum\n\n        ```java\n        @Getter\n        public enum Currency{\n            WON(\"￦\"),\n            DOLLAR(\"$\");\n\n            private String symbol;\n\n            Currency(String symbol){\n                this.symbol = symbol;\n            }\n        }\n        ```\n\n    -   ModelMapper\n\n        ```java\n        @Bean\n        public ModelMapper modelMapper(){\n            ModelMapper modelMapper = new ModelMapper();\n\n            Converter<Currency, String> currencyConverter = ctx -> ctx.getSource().getSymbol();\n            PropertiMap<Item, ItemDto> itemMap = new PropertyMap<>(){\n                protected void configure(){\n                    using(currencyConverter).map(source.getCurrency()).setCurrency(null);\n                }\n            }\n            modelMapper.addMappings(itemMap);\n\n            return modelMapper;\n        }\n        ```\n\n    -   MapStruct\n\n        ```java\n        @Mapping(source = \"item.currency\", target=\"currency\", qualifiedByName = \"currencyToSymbol\")\n        ItemDto toItemDto(Item item);\n\n        @Named(\"currencyToSymbol\")\n        static String currencyToSymbol(Currency currency){\n            return currency.getSymbol();\n        }\n        ```\n\n-   성능 차이 : MapStruct > ModelMapper  \n     출처 : [Java 매핑 프레임워크의 성능](https://recordsoflife.tistory.com/1251)\n\n### 결론\n\n난 이제 MapStruct 없이 JPA를 사용할 수 없는 몸이 되었다.\n우리나라에서는 ModelMapper의 점유율이 더 높다고 하는데 MapStruct 많이 쓰면 좋겠다.\n\n### 참조\n\nNHN Cloud Meetup [Object Mapping 어디까지 해봤니?](https://meetup.nhncloud.com/posts/213)\n","title":"Java Bean Mapping library 적용 - MapStruct","date":"2023-05-26","category":["backend","spring"],"tag":["MapStruct","jpa","java"]},"prev":{"id":"20230221","title":"wsl.exe 실행되지 않음","date":"2023-02-21","category":["OS","window"],"tag":["wsl","ubuntu"]},"next":{"id":"20230925","title":"Bastion Host 사용하여 RDS 접속하기","date":"2023-09-25","category":["Cloud","aws"],"tag":["BastionHost","RDS"]},"nearPost":[{"id":"20241023","title":"로컬에서 minikube로 k8s 맛보기","date":"2024-10-23","category":["infra","kubernetes"],"tag":["devops","k8s","ingress"]},{"id":"20240620","title":"기초 네트워크[유투브 조코딩 - 꼭 알아야 하는 네트워크 지식...(feat.강민철)","date":"2024-06-20","category":["infra","network"],"tag":["network","http"]},{"id":"20230925","title":"Bastion Host 사용하여 RDS 접속하기","date":"2023-09-25","category":["Cloud","aws"],"tag":["BastionHost","RDS"]},{"id":"20230221","title":"wsl.exe 실행되지 않음","date":"2023-02-21","category":["OS","window"],"tag":["wsl","ubuntu"]},{"id":"20230216","title":"Facade Pattern (파사드 패턴)","date":"2023-02-16","category":["SW","design pattern"],"tag":["oop","design pattern"]}]},"__N_SSG":true}