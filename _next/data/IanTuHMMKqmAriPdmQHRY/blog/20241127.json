{"pageProps":{"post":{"id":"20241127","content":"\n### 학습 배경\n\n프로젝트에 적용된 파일 업로드 방식이 2가지인 것을 확인하고 어떤 것으로 통일할지 결정하기 위해서 공부하였음\n\n# File Upload\n\n## @RequestParam\n\n`@RequestParam`을 사용하는 경우 file 데이터 외에 `json` 형식의 데이터는 받을 수 없다.\n\n### single file 예제\n\n```java\n    @PostMapping(\"/request-param/single\")\n    public String singleRequest(@RequestParam MultipartFile file){\n        return \"request param single \"+file.getOriginalFilename();\n    }\n```\n\n### multi file & other request param 예제\n\n-   여러개의 multi file paramter 사용 가능하며 `List<MultipartFile>` 도 사용 할 수 있다.\n-   다만 RequestParam이 너무 많으면 유지보수가 힘들어지기 때문에 적은 파라미터일 때는 사용을 고려해 볼 수 있겠다\n\n```java\n    @PostMapping(\"/multi-with-other-params\")\n    public String withOtherParamsRequest(@RequestParam MultipartFile file1, @RequestParam MultipartFile file2,\n                                         @RequestParam String name, @RequestParam String desc){\n        return \"request param with other params \"+file1.getOriginalFilename()+\"_\"+file2.getOriginalFilename()+\n                \"_\"+name+\"_\"+desc;\n    }\n```\n\n## @RequestPart\n\n`@RequestPart`를 사용하는 경우 file 데이터 외에 `@RequestPart`를 사용하여 `json` 데이터를 받을 수 있다.\n\n### single file & json 예제\n\n-   backend code\n\n```java\n    @PostMapping(\"/with-request-part\")\n    public String withRequestPart(@RequestPart MultipartFile file, @RequestPart RequestPartTestBody requestBody){\n        return \"request part with request part \"+file.getOriginalFilename()+\"_\"+requestBody.toString();\n    }\n\n    @Getter\n    @ToString\n    public class RequestPartTestBody {\n        private String name;\n        private String desc;\n    }\n```\n\n-   frontend code  \n    json 파일을 넘길 때 `new Blob()` 객체로 변환하고 `{type: \"application/json\"}` 으로 ContentType을 지정해줘야 정상적으로 동작한다.\n\n```js\nasync function submitRequestPartWithRequestPart() {\n    const bodyData = new FormData();\n    const file = document.querySelector(\"#file\").files;\n    bodyData.append(\"file\", file[0]);\n    bodyData.append(\n        \"requestBody\",\n        new Blob(\n            [\n                `{\"name\": \"${document.querySelector(\"#name\").value}\", \"desc\": \"${\n                    document.querySelector(\"#desc\").value\n                }\"}`,\n            ],\n            { type: \"application/json\" }\n        )\n    );\n\n    await post(bodyData, \"request-part/with-request-part\", \"request-part-with-request-part\");\n}\n\nasync function post(bodyData, uri, preId) {\n    const context = \"[[@{/}]]\";\n    await fetch(context + uri, {\n        method: \"POST\",\n        body: bodyData,\n    })\n        .then((res) => {\n            if (res.ok) {\n                return res.text();\n            } else {\n                return res.json();\n            }\n        })\n        .then((res) => {\n            if (typeof res == \"object\") {\n                document.querySelector(`#${preId}`).innerHTML = res.error;\n                document.querySelector(`#${preId}`).className = \"error\";\n            } else {\n                document.querySelector(`#${preId}`).innerHTML = res;\n                document.querySelector(`#${preId}`).className = \"result\";\n            }\n        });\n}\n```\n\n## @ModelAttribute\n\n`@ModelAttribute`를 사용하는 경우 file 타입 필드와 기타 json으로 받고싶은 데이터들을 RequestDto로 한번에 처리할 수 있다.\n\n### RequestDto 예제\n\n```java\n    @PostMapping(value = \"in-the-request-body\", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)\n    public String inTheRequestBody(@ModelAttribute ModelAttributeTest2Body requestBody){\n        return \"model attribute in the request body \"+requestBody.toString();\n    }\n\n    @Getter @Setter\n    public class ModelAttributeTest2Body {\n        private String name;\n        private String desc;\n        private MultipartFile file;\n\n        public String toString(){\n            return \"{\"+\n                    \"\\\"name\\\":\\\"\"+name+\"\\\",\"+\n                    \"\\\"desc\\\":\\\"\"+desc+\"\\\",\"+\n                    \"\\\"file\\\":\\\"\"+file.getOriginalFilename()+\"\\\"}\";\n        }\n    }\n```\n\n```js\nasync function submitModelAttributeInTheRequestBody() {\n    const bodyData = new FormData();\n    const file = document.querySelector(\"#file\").files;\n    bodyData.append(\"file\", file[0]);\n    bodyData.append(\"name\", document.querySelector(\"#name\").value);\n    bodyData.append(\"desc\", document.querySelector(\"#desc\").value);\n\n    await post(bodyData, \"model-attribute/in-the-request-body\", \"model-attribute-in-the-request-body\");\n}\n```\n\n### 전체 코드\n\n[request-annotation-test](https://github.com/m3rri/request-annotation-test)\n\n## 결론\n\n둘 중 하나로 통일하기 위해서 스터디를 했으나 결과적으로 상황에 따라 사용할 수 있음을 확인했다.  \n`@RequestPart`의 경우 file부/json부로 나눠야 하고 front에서 json을 생성하여 Blob 객체로 변환하는 작업까지 이루어져야 하기 때문에 번거로울 수 있다. `@ModelAttribute`의 경우에는 front에서 FormData에 각각 append하여도 requestBody에 자동으로(정확히는 변수명으로 추측되는 setter를 사용해서) 매핑된다.  \n하지만 내가 담당하고 있는 프로그램의 경우 request로 받는 json 구조가 굉장히 복잡하기 때문에 테스트 측면에서는 `@RequestPart`를 유지하는 것이 좋아보인다.\n\n추가로 각 어노테이션의 특징과 RequestDto로 매핑하는 과정을 정리하고자 한다.\n\n# Annotation별 특징, 데이터 매핑 방법\n\n[출처link](https://javaproject.tistory.com/113)\n\n## @RequestParam\n\n간단한 name-value 형태의 데이터를 주고받을 때 사용할 수 있다. `@RequestPart`와 마찬가지로 MultipartFile을 받을 때도 사용할 수 있다.  \n기본적으로 required 속성이 true이기 때문에 optional 데이터의 경우 `required=false` 설정을 해줘야 한다.\n\n## @RequestBody\n\nHTTP 요청으로 넘어오는 body 내용을 `HttpMessageConverter`를 통해 역직렬화한다. json 기반의 메시지를 사용하는 요청인 경우 적용될 수 있으며 Multipart요청이 아닌 데이터를 받는 역할을 한다.\n\n-   HttpMessageConverter\n    json 데이터를 역직렬화를 통해 객체로 만드는 주체.  \n    `RequestMappingHandlerAdapter`가 데이터의 MIME 타입을 확인한 후 `application/json`인 경우에는 `MappingJackson2HttpMessageConverter`를 사용하도록 선정한다.  \n    MappingJackson2HttpMessageConverter는 내부적으로 `ObjectMapper`를 사용하여 데이터를 변환한다.([출처link](https://sedangdang.tistory.com/305))  \n    `ObjectMapper`는 기본 생성자와 @Getter만 있으면 데이터를 변환할 수 있기 때문에 RequestDto에 @Setter annotation은 불필요하다.  \n    (정확히는 @Getter, @Setter 둘 중 하나만 있어도 되지만 객체 생성 후 변수에 접근하기 위해 @Getter를 사용)([출처link](https://blogshine.tistory.com/446))\n\n## @RequestPart\n\nMultipartFile이 포함되는 경우 `MultipartResolver`가 동작하여 역직렬화한다. 데이터에 MultipartFile이 포함되지 않는 경우 `@RequestBody`와 같이 동작하게 된다.  \n따라서 `@RequestBody`가 필요하지만 바이너리 데이터가 포함되는 경우 사용할 수 있다.\n\n## @ModelAttribute\n\nSpring Controller에서 값을 받을 때 default 로 적용되는 어노테이션이다. request body, request parameter 모두를 받을 수 있고 MultipartFile 이 포함되어 있을 때도 처리할 수 있다.  \n다만 `@RequestBody`, `@RequestPart`와 달리 `기본생성자`+`@Setter` 또는 `@AllArgsConstructor`가 있어야 RequestDto에 바인딩할 수 있다.([출처link](https://minchul-son.tistory.com/546))\n","title":"File Upload에 필요한 Request Annotation(@RequestParam, @RequestPart, @ModelAttribute, @RequestBody)","date":"2024-11-27","category":["backend","spring"],"tag":["@RequestPart","@RequestParam","@ModelAttribute","@RequestBody"]},"prev":{"id":"20241119","title":"웹 취약점","date":"2024-11-19","category":["sw","security"],"tag":["web security","web취약점"]},"next":{"id":"20241210","title":"Spring Security - OAuth2.0 사용 시 여러개의 리소스 서버를 지원하기","date":"2024-12-10","category":["backend","spring"],"tag":["spring security","oauth2.0","AuthenticationManagerResolver"]},"nearPost":[{"id":"20241210","title":"Spring Security - OAuth2.0 사용 시 여러개의 리소스 서버를 지원하기","date":"2024-12-10","category":["backend","spring"],"tag":["spring security","oauth2.0","AuthenticationManagerResolver"]},{"id":"20241119","title":"웹 취약점","date":"2024-11-19","category":["sw","security"],"tag":["web security","web취약점"]},{"id":"20241023","title":"로컬에서 minikube로 k8s 맛보기","date":"2024-10-23","category":["infra","kubernetes"],"tag":["devops","k8s","ingress"]},{"id":"20240620","title":"기초 네트워크[유투브 조코딩 - 꼭 알아야 하는 네트워크 지식...(feat.강민철)","date":"2024-06-20","category":["infra","network"],"tag":["network","http"]},{"id":"20230925","title":"Bastion Host 사용하여 RDS 접속하기","date":"2023-09-25","category":["Cloud","aws"],"tag":["BastionHost","RDS"]}]},"__N_SSG":true}