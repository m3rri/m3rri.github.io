{"pageProps":{"post":{"id":"20241210","content":"\n### 학습 배경\n\n각각 다른 OAuth 리소스 서버를 사용하는 서비스들에서 한 서버의 api를 호출할 수 있도록 변경하기 위해 학습하였다.\n\n처음에는 OAuth별로 백엔드 서버를 구축해야되나 했는데, 뭔가 방법이 있을 것 같아서 찾아보게 되었다.\n\n### 기존 설정\n\n-   application.yaml\n\n    -   issuer-uri : jwt를 발급한 인증 서버의 url을 지정. Spring Security는 이 정보를 기반으로 jwt를 검증한다.\n\n    -   jwk-set-uri : jwt를 검증하기 위해 필요한 공개키를 조회할 때 사용하는 jwk url은 spring security에서 자동으로 매핑하며, 아래와 같이 직접 지정해서 사용할 수 있다.\n\n    ```json\n    spring:\n      security:\n        oauth2:\n          resourceserver:\n            jwt:\n              issuer-uri: https://sso.server.com\n              jwk-set-uri: ${spring.security.oauth2.resourceserver.jwt.issuer-uri}/protocol/openid-connect/certs\n    ```\n\n-   WebSecurityConfig.java\n\n    -   oauth2ResourceServer method를 사용하여 Oauth2를 활성화 시키고 application.yaml에 설정된 `issuer-uri`를 통해 jwt를 검증한다.\n    -   검증된 jwt는 CustomUserConverter를 통해 decode 되고 Authentication 객체를 생성한다.\n    -   이후 BearerTokenAuthenticationFilter에 의해 Authentication 정보가 SecurityContextHolder에 저장된다.(Spring Security가 호출)\n\n    ```java\n    @Configuration\n    @EnableWebSecurity\n    @RequiredArgsConstructor\n    public class WebSecurityConfig {\n\n        private final CustomUserConverter customUserConverter;\n\n        @Bean\n        public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n            http\n                .csrf(AbstractHttpConfigurer::disable)\n                .sessionManagement(sessionConfig -> sessionConfig.sessionCreationPolicy(SessionCreationPolicy.STATELESS))\n                .authorizeHttpRequests(request -> request.anyRequest().permitAll())\n                .oauth2ResourceServer(oauth2Config -> oauth2Config\n                    .jwt(jwtConfig -> jwtConfig.jwtAuthenticationConverter(customUserConverter))\n                );\n\n            return http.build();\n        }\n    }\n    ```\n\n위의 설정은 resource server가 1개일 때 사용 가능하다\n\n### 변경 설정\n\n-   application.yaml\n\n    ```json\n    resourceserver:\n      issuer-uri-main: http://sso.server1.com\n      issuer-uri-sub: http://sso.server2.com\n    ```\n\n    위와 같이 issuer-uri를 각각 지정해준다\n\n-   WebSecurityConfig.java\n\n    ```java\n    @Configuration\n    @EnableWebSecurity\n    @RequiredArgsConstructor\n    public class WebSecurityConfig {\n\n        private final CustomUserConverterMain customUserConverterMain;\n        private final CustomUserConverterSub customUserConverterSub;\n\n        @Value(\"${resourceserver.issuer-uri-main}\")\n        private final String issuerUriMain;\n        @Value(\"${resourceserver.issuer-uri-sub}\")\n        private final String issuerUriSub;\n\n        @Bean\n        public SecurityFilterChain filterChain(HttpSecurity http, CustomAuthenticationFilter customAuthenticationFilter) throws Exception {\n            http\n                .csrf(AbstractHttpConfigurer::disable)\n                .sessionManagement(sessionConfig -> sessionConfig.sessionCreationPolicy(SessionCreationPolicy.STATELESS))\n                .authorizeHttpRequests(request -> request.anyRequest().permitAll())\n    \t\t    .addFilterBefore(customAuthenticationFilter, BearerTokenAuthenticationFilter.class)\n                .oauth2ResourceServer(oauth2Config -> oauth2Config\n                    .authenticationManagerResolver(customAuthenticationManagerResolver())\n                );\n\n            return http.build();\n        }\n\n        @Bean\n        public AuthenticationManagerResolver<HttpServletRequest> customAuthenticationManagerResolver() {\n            return request -> {\n                String authServer = request.getHeader(\"Auth-Server\");\n\n                if (authServer.equals(\"main\")) {\n                    return authenticationManagerMain(issuerUriMain);\n                } else if (authServer.equals(\"sub\")) {\n                    String path = request.getRequestURI();\n                    if (path.contains(\"/product\")) {\n                        return authenticationManagerSub(issuerUriSub);\n                    }\n                }\n                throw new AuthenticationServiceException(ExceptionCode.ISSUER_MISMATCHED.getMessage());\n            };\n        }\n\n        private AuthenticationManager authenticationManagerMain(String issuerLocation) {\n            JwtDecoder jwtDecoder = JwtDecoders.fromIssuerLocation(issuerLocation);\n            JwtAuthenticationProvider provider = new JwtAuthenticationProvider(jwtDecoder);\n            provider.setJwtAuthenticationConverter(labIDEUserConverterMain);\n\n            return provider::authenticate;\n        }\n\n        private AuthenticationManager authenticationManagerSub(String issuerLocation) {\n            JwtDecoder jwtDecoder = JwtDecoders.fromIssuerLocation(issuerLocation);\n            JwtAuthenticationProvider provider = new JwtAuthenticationProvider(jwtDecoder);\n            provider.setJwtAuthenticationConverter(labIDEUserConverterSub);\n\n            return provider::authenticate;\n        }\n    }\n    ```\n\n    -   `.jwt()` 대신 `.authenticationManagerResolver`를 사용하여 AuthenticationManager를 직접 생성할 수 있다.\n    -   예시는 Header를 사용하여 main, sub issuer를 구분하고, sub에서 사용할 수 있는 api를 path로 제한하였다.\n    -   `customAuthenticationManagerResolver`에서 던지는 AuthenticationServiceException 예외를 처리하기 위해 `.addFilterBefore`로 customAuthenticationFilter를 등록했다.\n\n        -   아래와 같이 사용하지 않는 경우 그대로 500에러를 반환하기 때문에 HttpServletResponse 객체에 직접 작업을 해주었다.\n\n        ```java\n          @Component\n          public class CusomAuthenticationFilter extends OncePerRequestFilter {\n              private final AuthenticationManagerResolver<HttpServletRequest> authenticationManagerResolver;\n\n              public CusomAuthenticationFilter(AuthenticationManagerResolver<HttpServletRequest> resolver) {\n                  this.authenticationManagerResolver = resolver;\n              }\n\n              @Override\n              protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)\n                  throws IOException {\n                  try {\n                      authenticationManagerResolver.resolve(request);\n\n                      filterChain.doFilter(request, response);\n                  } catch (AuthenticationException ex) {\n                      SecurityContextHolder.clearContext();\n                      String errorDescription = ex.getMessage();\n                      ObjectMapper mapper = new ObjectMapper().registerModule(new JavaTimeModule());\n\n                      ErrorMessage errorMessage = ErrorMessage.builder()\n                          .statusCode(HttpStatus.UNAUTHORIZED.value())\n                          .message(errorDescription)\n                          .timestamp(LocalDateTime.now())\n                          .build();\n\n                      response.getWriter().write(mapper.writeValueAsString(errorMessage));\n                      response.setStatus(HttpStatus.UNAUTHORIZED.value());\n                  }\n              }\n          }\n        ```\n","title":"Spring Security - OAuth2.0 사용 시 여러개의 리소스 서버를 지원하기","date":"2024-12-10","category":["backend","spring"],"tag":["spring security","oauth2.0","AuthenticationManagerResolver"]},"prev":{"id":"20241127","title":"File Upload에 필요한 Request Annotation(@RequestParam, @RequestPart, @ModelAttribute, @RequestBody)","date":"2024-11-27","category":["backend","spring"],"tag":["@RequestPart","@RequestParam","@ModelAttribute","@RequestBody"]},"next":null,"nearPost":[{"id":"20241127","title":"File Upload에 필요한 Request Annotation(@RequestParam, @RequestPart, @ModelAttribute, @RequestBody)","date":"2024-11-27","category":["backend","spring"],"tag":["@RequestPart","@RequestParam","@ModelAttribute","@RequestBody"]},{"id":"20241119","title":"웹 취약점","date":"2024-11-19","category":["sw","security"],"tag":["web security","web취약점"]},{"id":"20241023","title":"로컬에서 minikube로 k8s 맛보기","date":"2024-10-23","category":["infra","kubernetes"],"tag":["devops","k8s","ingress"]},{"id":"20240620","title":"기초 네트워크[유투브 조코딩 - 꼭 알아야 하는 네트워크 지식...(feat.강민철)","date":"2024-06-20","category":["infra","network"],"tag":["network","http"]},{"id":"20230925","title":"Bastion Host 사용하여 RDS 접속하기","date":"2023-09-25","category":["Cloud","aws"],"tag":["BastionHost","RDS"]}]},"__N_SSG":true}