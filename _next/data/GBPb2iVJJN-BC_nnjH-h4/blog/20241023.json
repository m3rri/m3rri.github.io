{"pageProps":{"post":{"id":"20241023","content":"\n### 학습 배경\n\n-   이미 회사 개발 환경은 k8s로 돌아가고 있지만 사용만 하고 자세하게는 몰라서 로컬에서 간단한 모델을 구현해보기로함\n-   로컬에서 url path로 로드밸런싱 하는 ingress 구조\n\n---\n\n## 미리 준비할 것\n\n### 1. linux 운영체제 환경\n\n현재 회사에서 Azure 사용 중이라 azure vm 을 사용했다\n\n-   Ubuntu Server 24.04 LTS x64\n-   머신은 Standard B2s 사용 : 2 vcpu, 4GiB 메모리\n    -   minikube 사용을 위해 2 pcu, 2GB 를 선택했다 ([minikube 공식문서](https://minikube.sigs.k8s.io/docs/start/?arch=%2Fwindows%2Fx86-64%2Fstable%2F.exe+download))\n\n### 2. 간단한 Spring Boot application\n\n```java\n@RestController\n@Slf4j\npublic class KubeController {\n\n    @GetMapping(\"/domain\")\n    public String domain(){\n        log.info(\"===== domain service =====\");\n        log.info(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n        log.info(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n        log.info(\"==========================\");\n        return \"domain\";\n    }\n\n    @GetMapping(\"/non-domain\")\n    public String nonDomain(){\n        log.info(\"===== non domain =====\");\n        log.info(\"        BLANK\");\n        log.info(\"======================\");\n        return \"non domain\";\n    }\n}\n```\n\n`bootJar` 실행해서 jar 파일 생성해둠\n\n### 3. Docker image 준비\n\n-   Dockerfile\n\n```Docker\nFROM openjdk:17-jdk-alpine\n\nWORKDIR /app\n\nCOPY target/spring-app.jar /app/spring-app.jar\n# target/ 디렉토리에 있는 Spring Boot JAR 파일을 Docker 컨테이너의 /app 디렉토리에 복사\n\nEXPOSE 8080\n\nENTRYPOINT [\"java\", \"-jar\", \"spring-app.jar\"]\n```\n\n-   image build\n\n```bash\nC:\\> docker build -t spring-app .\n# 현재 디렉토리 (.)에 있는 Dockerfile로 spring-app 이미지 생성\n# docker images로 생성된 이미지 확인 가능\n```\n\n-   docker hub로 업로드\n\n```bash\ndocker login -u username\n\ndocker tag spring-app <username>/spring-app\ndocker push <username>/spring-app\n```\n\n## 필요한 프로그램 설치\n\n### 1. docker\n\n```bash\n# 필요한 패키지 설치\nazureuser@m3rri17:~$ sudo apt-get install apt-transport-https ca-certificates curl gnupg-agent software-properties-common\n# docker 공식 gpg 키 추가\nazureuser@m3rri17:~$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -\n# docker 공식 apt 저장소 추가\nazureuser@m3rri17:~$ sudo add-apt-repository \"deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\"\n# docker 설치\nazureuser@m3rri17:~$ sudo apt-get install docker-ce docker-ce-cli containerd.io\n```\n\nminikube driver를 docker로 사용하기 위해서는 아래 명령어를 추가로 실행해줘야 한다\n\n```bash\nazureuser@m3rri17:~$ sudo usermod -aG docker $USER && newgrp docker\n```\n\n⚠위 명령을 실행하지 않고 minikube를 시작하려고 할 때 발생하는 에러\n\n```bash\nazureuser@m3rri17:~$ minikube start --driver=docker --memory 200\n😄  minikube v1.34.0 on Ubuntu 24.04\n✨  Using the docker driver based on user configuration\n\n💣  Exiting due to PROVIDER_DOCKER_NEWGRP: \"docker version --format <no value>-<no value>:<no value>\" exit status 1: permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get \"http://%2Fvar%2Frun%2Fdocker.sock/v1.47/version\": dial unix /var/run/docker.sock: connect: permission denied\n💡  Suggestion: Add your user to the 'docker' group: 'sudo usermod -aG docker $USER && newgrp docker'\n📘  Documentation: https://docs.docker.com/engine/install/linux-postinstall/\n```\n\n`💡  Suggestion` 부분의 명령어를 실행\n\n### 2. minikube\n\n```bash\nazureuser@m3rri17:~$ curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64\nazureuser@m3rri17:~$ sudo install minikube-linux-amd64 /usr/local/bin/minikube && rm minikube-linux-amd64\n```\n\n출처 : [minikube 공식문서](https://minikube.sigs.k8s.io/docs/start/?arch=%2Fwindows%2Fx86-64%2Fstable%2F.exe+download)\n\n### 3. kubectl\n\n```bash\n# download the lastes release\nazureuser@m3rri17:~$ curl -LO \"https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl\n```\n\n```bash\n# install kubectl\nazureuser@m3rri17:~$ sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl\n# version check\nazureuser@m3rri17:~$ kubectl version --client\n```\n\n출처 : [kubernetes 공식문서](https://kubernetes.io/ko/docs/tasks/tools/install-kubectl-linux/)\n\n### 4. ingress-controller\n\n```bash\nazureuser@m3rri17:~$ minikube addons enable ingress\n💡  ingress is an addon maintained by Kubernetes. For any concerns contact minikube on GitHub.\nYou can view the list of minikube maintainers at: https://github.com/kubernetes/minikube/blob/master/OWNERS\n    ▪ Using image registry.k8s.io/ingress-nginx/controller:v1.11.2\n    ▪ Using image registry.k8s.io/ingress-nginx/kube-webhook-certgen:v1.4.3\n    ▪ Using image registry.k8s.io/ingress-nginx/kube-webhook-certgen:v1.4.3\n🔎  Verifying ingress addon...\n🌟  The 'ingress' addon is enabled\n\nazureuser@m3rri17:~$ kubectl get all -n ingress-nginx\nNAME                                           READY   STATUS      RESTARTS   AGE\npod/ingress-nginx-admission-create-p7mcn       0/1     Completed   0          89s\npod/ingress-nginx-admission-patch-p5bf4        0/1     Completed   1          89s\npod/ingress-nginx-controller-bc57996ff-p9488   1/1     Running     0          89s\n\nNAME                                         TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)                      AGE\nservice/ingress-nginx-controller             NodePort    10.107.25.163    <none>        80:31473/TCP,443:30846/TCP   89s\nservice/ingress-nginx-controller-admission   ClusterIP   10.101.131.201   <none>        443/TCP                      89s\n\nNAME                                       READY   UP-TO-DATE   AVAILABLE   AGE\ndeployment.apps/ingress-nginx-controller   1/1     1            1           89s\n\nNAME                                                 DESIRED   CURRENT   READY   AGE\nreplicaset.apps/ingress-nginx-controller-bc57996ff   1         1         1       89s\n\nNAME                                       STATUS     COMPLETIONS   DURATION   AGE\njob.batch/ingress-nginx-admission-create   Complete   1/1           8s         89s\njob.batch/ingress-nginx-admission-patch    Complete   1/1           9s         89s\n```\n\n## k8s 구동\n\n### 1. minikube 시작\n\n```bash\nazureuser@m3rri17:~$ minikube start --driver=docker --memory 2048\n# --driver=docker : driver 겹쳐서 에러발생하는 경우 사용\n# --memory 2048 : ram 에 여유가 없어서 따로 지정함\n\nazureuser@m3rri17:~$ minikube status\n# 아래와 같이 나오면 정상\nminikube\ntype: Control Plane\nhost: Running\nkubelet: Running\napiserver: Running\nkubeconfig: Configured\n\nazureuser@m3rri17:~$ minikube ip\n# ip 확인하여 이후 Ingress 파일 작성 단계에서 사용\n```\n\n### 2. Deployment\n\n-   file 생성\n    -   spring-deployment-1.yaml\n        ```yaml\n        apiVersion: apps/v1\n        kind: Deployment\n        metadata:\n            name: spring-boot-deployment-1 # deployment의 이름\n        spec:\n            replicas: 1 # 생성할 pod 수\n            selector:\n                matchLabels:\n                    app: spring-boot-app-1 # app 이름 service 파일의 spec.selector.app 에서 동일한 이름 사용하면 매핑됨\n            template:\n                metadata:\n                    labels:\n                        app: spring-boot-app-1\n                spec:\n                    containers:\n                        - name: spring-boot-container-1\n                          image: <dockerhub-username>/spring-app # Docker Hub에서 가져올 이미지\n                          ports:\n                              - containerPort: 8080 # Spring Boot 기본 포트\n        ```\n    -   spring-deployment-2.yaml\n        ```yaml\n        apiVersion: apps/v1\n        kind: Deployment\n        metadata:\n            name: spring-boot-app-2\n        spec:\n            replicas: 1\n            selector:\n                matchLabels:\n                    app: spring-boot-app-2\n            template:\n                metadata:\n                    labels:\n                        app: spring-boot-app-2\n                spec:\n                    containers:\n                        - name: spring-boot-container-2\n                          image: <dockerhub-username>/spring-app\n                          ports:\n                              - containerPort: 8080\n        ```\n-   클러스터에 적용\n\n```bash\nazureuser@m3rri17:~$ kubectl apply -f spring-deployment-1.yaml\nazureuser@m3rri17:~$ kubectl apply -f spring-deployment-2.yaml\nazureuser@m3rri17:~$ kubectl get pods # pod name 확인\nNAME                                        READY   STATUS    RESTARTS   AGE\nspring-boot-deployment-1-5b4b9d89f8-2sjcq   1/1     Running   0          21s\nspring-boot-deployment-2-cd877558-jqw4x     1/1     Running   0          7s\n\nazureuser@m3rri17:~$ kubectl logs <pod-name> # -f는 실시간 로그 확인 결과는 아래 다시 정리\n```\n\n### 3. Service\n\n-   file 생성\n    -   spring-service-1.yaml\n        ```yaml\n        apiVersion: v1\n        kind: Service\n        metadata:\n            name: spring-boot-service-1 # service 이름. ingress 파일의 spec.rules.http.paths.backend.service.name에 동일하게 사용하여 매핑\n        spec:\n            selector:\n                app: spring-boot-app-1\n            ports:\n                - protocol: TCP\n                  port: 80\n                  targetPort: 8080 # 80포트로 들어온 요청을 8080 포트로 연결\n        ```\n    -   spring-service-2.yaml\n        ```yaml\n        apiVersion: v1\n        kind: Service\n        metadata:\n            name: spring-boot-service-2\n        spec:\n            selector:\n                app: spring-boot-app-2\n            ports:\n                - protocol: TCP\n                  port: 80\n                  targetPort: 8080\n        ```\n-   클러스터에 적용\n\n```bash\nazureuser@m3rri17:~$ kubectl apply -f spring-service-1.yaml\nazureuser@m3rri17:~$ kubectl apply -f spring-service-2.yaml\nazureuser@m3rri17:~$ kubectl get svc\nNAME                    TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)        AGE\nkubernetes              ClusterIP   10.96.0.1      <none>        443/TCP        6m14s\nspring-boot-service-1   NodePort    10.98.26.57    <none>        80:32309/TCP   7s\nspring-boot-service-2   NodePort    10.99.23.101   <none>        80:32206/TCP   3s\n```\n\n### 4. Ingress\n\n-   file 생성\n    ingress.yaml\n    ```yaml\n    apiVersion: networking.k8s.io/v1\n    kind: Ingress\n    metadata:\n        name: spring-boot-ingress\n        annotations:\n            nginx.ingress.kubernetes.io/rewrite-target: /\n    spec:\n        rules:\n            - host: \"<minikube-ip>.nip.io\" # 또는 도메인 이름\n              http:\n                  paths:\n                      - path: /domain\n                        pathType: Prefix\n                        backend:\n                            service:\n                                name: spring-boot-service-1\n                                port:\n                                    number: 80\n                      - path: /non-domain\n                        pathType: Prefix\n                        backend:\n                            service:\n                                name: spring-boot-service-2\n                                port:\n                                    number: 80\n    ```\n-   클러스터에 적용\n\n```bash\nazureuser@m3rri17:~$ kubectl apply -f ingress.yaml\nazureuser@m3rri17:~$ kubectl get all -n ingress-nginx\nNAME                                           READY   STATUS      RESTARTS   AGE\npod/ingress-nginx-admission-create-p7mcn       0/1     Completed   0          9m51s\npod/ingress-nginx-admission-patch-p5bf4        0/1     Completed   1          9m51s\npod/ingress-nginx-controller-bc57996ff-p9488   1/1     Running     0          9m51s\n\nNAME                                         TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)                      AGE\nservice/ingress-nginx-controller             NodePort    10.107.25.163    <none>        80:31473/TCP,443:30846/TCP   9m51s\nservice/ingress-nginx-controller-admission   ClusterIP   10.101.131.201   <none>        443/TCP                      9m51s\n\nNAME                                       READY   UP-TO-DATE   AVAILABLE   AGE\ndeployment.apps/ingress-nginx-controller   1/1     1            1           9m51s\n\nNAME                                                 DESIRED   CURRENT   READY   AGE\nreplicaset.apps/ingress-nginx-controller-bc57996ff   1         1         1       9m51s\n\nNAME                                       STATUS     COMPLETIONS   DURATION   AGE\njob.batch/ingress-nginx-admission-create   Complete   1/1           8s         9m51s\njob.batch/ingress-nginx-admission-patch    Complete   1/1           9s         9m51s\n```\n\n### 5. 테스트 및 로그 확인\n\n-   /domain\n\n```bash\nazureuser@m3rri17:~$ curl http://192.168.49.2.nip.io:80/domain\ndomain\n\nazureuser@m3rri17:~$ kubectl logs spring-boot-deployment-1-5b4b9d89f8-2sjcq\n\n  .   ____          _            __ _ _\n /\\\\ / ___'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\\n( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\\n \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )\n  '  |____| .__|_| |_|_| |_\\__, | / / / /\n =========|_|==============|___/=/_/_/_/\n\n :: Spring Boot ::                (v3.3.4)\n\n2024-10-22T07:15:39.011Z  INFO 1 --- [kubetarget] [           main] c.e.kubetarget.KubetargetApplication     : Starting KubetargetApplication v0.0.1-SNAPSHOT using Java 17-ea with PID 1 (/app/spring-app.jar started by root in /app)\n2024-10-22T07:15:39.016Z  INFO 1 --- [kubetarget] [           main] c.e.kubetarget.KubetargetApplication     : No active profile set, falling back to 1 default profile: \"default\"\n2024-10-22T07:15:41.258Z  INFO 1 --- [kubetarget] [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port 8080 (http)\n2024-10-22T07:15:41.297Z  INFO 1 --- [kubetarget] [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat]\n2024-10-22T07:15:41.297Z  INFO 1 --- [kubetarget] [           main] o.apache.catalina.core.StandardEngine    : Starting Servlet engine: [Apache Tomcat/10.1.30]\n2024-10-22T07:15:41.608Z  INFO 1 --- [kubetarget] [           main] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext\n2024-10-22T07:15:41.614Z  INFO 1 --- [kubetarget] [           main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 2529 ms\n2024-10-22T07:15:43.224Z  INFO 1 --- [kubetarget] [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port 8080 (http) with context path '/'\n2024-10-22T07:15:43.262Z  INFO 1 --- [kubetarget] [           main] c.e.kubetarget.KubetargetApplication     : Started KubetargetApplication in 4.891 seconds (process running for 5.76)\n2024-10-22T07:23:43.510Z  INFO 1 --- [kubetarget] [nio-8080-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring DispatcherServlet 'dispatcherServlet'\n2024-10-22T07:23:43.510Z  INFO 1 --- [kubetarget] [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : Initializing Servlet 'dispatcherServlet'\n2024-10-22T07:23:43.512Z  INFO 1 --- [kubetarget] [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : Completed initialization in 2 ms\n2024-10-22T07:25:43.823Z  INFO 1 --- [kubetarget] [nio-8080-exec-5] c.e.k.d.controller.DomainController      : ===== domain service =====\n2024-10-22T07:25:43.823Z  INFO 1 --- [kubetarget] [nio-8080-exec-5] c.e.k.d.controller.DomainController      : ABCDEFGHIJKLMNOPQRSTUVWXYZ\n2024-10-22T07:25:43.823Z  INFO 1 --- [kubetarget] [nio-8080-exec-5] c.e.k.d.controller.DomainController      : ABCDEFGHIJKLMNOPQRSTUVWXYZ\n2024-10-22T07:25:43.823Z  INFO 1 --- [kubetarget] [nio-8080-exec-5] c.e.k.d.controller.DomainController      : ==========================\n```\n\n-   /non-domain\n\n```bash\nazureuser@m3rri17:~$ curl http://192.168.49.2.nip.io:80/non-domain\nnon domain\n\nazureuser@m3rri17:~$ kubectl logs spring-boot-deployment-2-cd877558-jqw4x\n\n  .   ____          _            __ _ _\n /\\\\ / ___'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\\n( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\\n \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )\n  '  |____| .__|_| |_|_| |_\\__, | / / / /\n =========|_|==============|___/=/_/_/_/\n\n :: Spring Boot ::                (v3.3.4)\n\n2024-10-22T07:15:42.639Z  INFO 1 --- [kubetarget] [           main] c.e.kubetarget.KubetargetApplication     : Starting KubetargetApplication v0.0.1-SNAPSHOT using Java 17-ea with PID 1 (/app/spring-app.jar started by root in /app)\n2024-10-22T07:15:42.657Z  INFO 1 --- [kubetarget] [           main] c.e.kubetarget.KubetargetApplication     : No active profile set, falling back to 1 default profile: \"default\"\n2024-10-22T07:15:44.533Z  INFO 1 --- [kubetarget] [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port 8080 (http)\n2024-10-22T07:15:44.551Z  INFO 1 --- [kubetarget] [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat]\n2024-10-22T07:15:44.552Z  INFO 1 --- [kubetarget] [           main] o.apache.catalina.core.StandardEngine    : Starting Servlet engine: [Apache Tomcat/10.1.30]\n2024-10-22T07:15:44.697Z  INFO 1 --- [kubetarget] [           main] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext\n2024-10-22T07:15:44.699Z  INFO 1 --- [kubetarget] [           main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 1821 ms\n2024-10-22T07:15:45.653Z  INFO 1 --- [kubetarget] [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port 8080 (http) with context path '/'\n2024-10-22T07:15:45.706Z  INFO 1 --- [kubetarget] [           main] c.e.kubetarget.KubetargetApplication     : Started KubetargetApplication in 4.273 seconds (process running for 5.877)\n2024-10-22T07:25:51.778Z  INFO 1 --- [kubetarget] [nio-8080-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring DispatcherServlet 'dispatcherServlet'\n2024-10-22T07:25:51.778Z  INFO 1 --- [kubetarget] [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : Initializing Servlet 'dispatcherServlet'\n2024-10-22T07:25:51.780Z  INFO 1 --- [kubetarget] [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : Completed initialization in 1 ms\n2024-10-22T07:25:51.822Z  INFO 1 --- [kubetarget] [nio-8080-exec-1] c.e.k.d.controller.DomainController      : ===== non domain =====\n2024-10-22T07:25:51.822Z  INFO 1 --- [kubetarget] [nio-8080-exec-1] c.e.k.d.controller.DomainController      :         BLANK\n2024-10-22T07:25:51.822Z  INFO 1 --- [kubetarget] [nio-8080-exec-1] c.e.k.d.controller.DomainController      : ======================\n```\n\npath에 따라 deployment1과 deployment2로 요청이 잘 나뉘어 들어갔다\n","title":"로컬에서 minikube로 k8s 맛보기","date":"2024-10-23","category":["infra","kubernetes"],"tag":["devops","k8s","ingress"]},"prev":{"id":"20240620","title":"기초 네트워크[유투브 조코딩 - 꼭 알아야 하는 네트워크 지식...(feat.강민철)","date":"2024-06-20","category":["infra","network"],"tag":["network","http"]},"next":{"id":"20241119","title":"웹 취약점","date":"2024-11-19","category":["sw","security"],"tag":["web security","web취약점"]},"nearPost":[{"id":"20241210","title":"Spring Security - OAuth2.0 사용 시 여러개의 리소스 서버를 지원하기","date":"2024-12-10","category":["backend","spring"],"tag":["spring security","oauth2.0","AuthenticationManagerResolver"]},{"id":"20241127","title":"File Upload에 필요한 Request Annotation(@RequestParam, @RequestPart, @ModelAttribute, @RequestBody)","date":"2024-11-27","category":["backend","spring"],"tag":["@RequestPart","@RequestParam","@ModelAttribute","@RequestBody"]},{"id":"20241119","title":"웹 취약점","date":"2024-11-19","category":["sw","security"],"tag":["web security","web취약점"]},{"id":"20240620","title":"기초 네트워크[유투브 조코딩 - 꼭 알아야 하는 네트워크 지식...(feat.강민철)","date":"2024-06-20","category":["infra","network"],"tag":["network","http"]},{"id":"20230925","title":"Bastion Host 사용하여 RDS 접속하기","date":"2023-09-25","category":["Cloud","aws"],"tag":["BastionHost","RDS"]}]},"__N_SSG":true}